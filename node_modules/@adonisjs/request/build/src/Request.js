"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const lodash_1 = require("lodash");
const getValue = require("get-value");
const qs = require("qs");
const proxyaddr = require("proxy-addr");
const net_1 = require("net");
const typeIs = require("type-is");
const accepts = require("accepts");
const fresh = require("fresh");
const macroable_1 = require("macroable");
const cuid = require("cuid");
const cookie_1 = require("@adonisjs/cookie");
class Request extends macroable_1.Macroable {
    constructor(request, response, _config, _secret) {
        super();
        this.request = request;
        this.response = response;
        this._config = _config;
        this._secret = _secret;
        this.parsedUrl = url_1.parse(this.request.url, false);
        this._body = {};
        this._all = {};
        this._original = {};
        this._qs = {};
        this._raw = null;
        this._lazyAccepts = null;
        this._parsedCookies = null;
        this._parseQueryString();
    }
    _parseQueryString() {
        if (this.parsedUrl.query) {
            this.updateQs(qs.parse(this.parsedUrl.query));
            this._original = Object.assign({}, this._all);
        }
    }
    _parseCookies() {
        if (!this._parsedCookies) {
            this._parsedCookies = cookie_1.parse(this.header('cookie'), this._secret);
        }
    }
    _initiateAccepts() {
        this._lazyAccepts = this._lazyAccepts || accepts(this.request);
    }
    id() {
        let requestId = this.header('x-request-id');
        if (!requestId) {
            requestId = cuid();
            this.request.headers['x-request-id'] = requestId;
        }
        return requestId;
    }
    setInitialBody(body) {
        if (this._original && Object.isFrozen(this._original)) {
            throw new Error('Cannot re-set initial body. Use request.updateBody instead');
        }
        this.updateBody(body);
        this._original = Object.freeze(Object.assign({}, this._all));
    }
    updateBody(body) {
        this._body = body;
        this._all = Object.assign({}, this._body, this._qs);
    }
    updateRawBody(rawBody) {
        this._raw = rawBody;
    }
    updateQs(data) {
        this._qs = data;
        this._all = Object.assign({}, this._body, this._qs);
    }
    get() {
        return this._qs;
    }
    post() {
        return this._body;
    }
    all() {
        return this._all;
    }
    original() {
        return this._original;
    }
    raw() {
        return this._raw;
    }
    input(key, defaultValue) {
        return getValue(this._all, key, { default: defaultValue });
    }
    except(keys) {
        return lodash_1.omit(this._all, keys);
    }
    only(keys) {
        return lodash_1.pick(this._all, keys);
    }
    intended() {
        return this.request.method;
    }
    method() {
        if (this._config.allowMethodSpoofing && this.intended() === 'POST') {
            return this.input('_method', this.intended()).toUpperCase();
        }
        return this.intended();
    }
    headers() {
        return this.request.headers;
    }
    header(key, defaultValue) {
        key = key.toLowerCase();
        const headers = this.headers();
        switch (key) {
            case 'referer':
            case 'referrer':
                return headers.referrer || headers.referer || defaultValue;
            default:
                return headers[key] || defaultValue;
        }
    }
    ip() {
        const ipFn = this._config.getIp;
        if (typeof (ipFn) === 'function') {
            return ipFn(this);
        }
        return proxyaddr(this.request, this._config.trustProxy);
    }
    ips() {
        return proxyaddr.all(this.request, this._config.trustProxy);
    }
    protocol() {
        const protocol = this.parsedUrl.protocol;
        if (!this._config.trustProxy(this.request.connection.remoteAddress, 0)) {
            return protocol;
        }
        const forwardedProtocol = this.header('X-Forwarded-Proto');
        return forwardedProtocol ? forwardedProtocol.split(/\s*,\s*/)[0] : 'http';
    }
    secure() {
        return this.protocol() === 'https';
    }
    hostname() {
        let host = this.header('host');
        if (this._config.trustProxy(this.request.connection.remoteAddress, 0)) {
            host = this.header('X-Forwarded-Host') || host;
        }
        if (!host) {
            return null;
        }
        const offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
        const index = host.indexOf(':', offset);
        return index !== -1 ? host.substring(0, index) : host;
    }
    subdomains() {
        const hostname = this.hostname();
        if (!hostname || net_1.isIP(hostname)) {
            return [];
        }
        const offset = this._config.subdomainOffset;
        const subdomains = hostname.split('.').reverse().slice(offset);
        if (subdomains[subdomains.length - 1] === 'www') {
            subdomains.splice(subdomains.length - 1, 1);
        }
        return subdomains;
    }
    ajax() {
        const xRequestedWith = this.header('X-Requested-With', '');
        return xRequestedWith.toLowerCase() === 'xmlhttprequest';
    }
    pjax() {
        return !!this.header('X-Pjax');
    }
    url(includeQueryString) {
        const pathname = this.parsedUrl.pathname;
        return includeQueryString ? `${pathname}?${this.parsedUrl.query}` : pathname;
    }
    completeUrl(includeQueryString) {
        const protocol = this.protocol();
        const hostname = this.hostname();
        return `${protocol}://${hostname}${this.url(includeQueryString)}`;
    }
    is(types) {
        return typeIs(this.request, types) || null;
    }
    accepts(types) {
        this._initiateAccepts();
        return this._lazyAccepts.type(types) || null;
    }
    types() {
        this._initiateAccepts();
        return this._lazyAccepts.types();
    }
    language(languages) {
        this._initiateAccepts();
        return this._lazyAccepts.language(languages) || null;
    }
    languages() {
        this._initiateAccepts();
        return this._lazyAccepts.languages();
    }
    charset(charsets) {
        this._initiateAccepts();
        return this._lazyAccepts.charset(charsets) || null;
    }
    charsets() {
        this._initiateAccepts();
        return this._lazyAccepts.charsets();
    }
    encoding(encodings) {
        this._initiateAccepts();
        return this._lazyAccepts.encoding(encodings) || null;
    }
    encodings() {
        this._initiateAccepts();
        return this._lazyAccepts.encodings();
    }
    hasBody() {
        return typeIs.hasBody(this.request);
    }
    fresh() {
        if (['GET', 'HEAD'].indexOf(this.intended()) === -1) {
            return false;
        }
        const status = this.response.statusCode;
        if ((status >= 200 && status < 300) || status === 304) {
            return fresh(this.headers(), this.response.getHeaders());
        }
        return false;
    }
    stale() {
        return !this.fresh();
    }
    cookies() {
        this._parseCookies();
        return this._parsedCookies.signedCookies;
    }
    cookie(key, defaultValue) {
        this._parseCookies();
        return getValue(this._parsedCookies.signedCookies, key, { default: defaultValue });
    }
    plainCookies() {
        this._parseCookies();
        return this._parsedCookies.plainCookies;
    }
    plainCookie(key, defaultValue) {
        this._parseCookies();
        return getValue(this._parsedCookies.plainCookies, key, { default: defaultValue });
    }
}
Request._macros = {};
Request._getters = {};
exports.Request = Request;
